#!/usr/bin/python3
import re
import sys
import requests
import pdb
import argparse
import json
import os
from colorama import Fore
import signal
import pydoc

def getTerminalColumns():
    return os.get_terminal_size().columns

def def_handler(sig,frame):
    print(f"\n\n{Fore.RED}[-] Exiting{Fore.RESET}")
    sys.exit(0)

signal.signal(signal.SIGINT, def_handler)    

def checkIfNeededExtraSpace(sideAvailableSpace):
    if re.match("\d+\.5", str(sideAvailableSpace)) != None:
        spaceRefillBecauseNotIntResult = ' '
    else:
        spaceRefillBecauseNotIntResult = ''
    return spaceRefillBecauseNotIntResult

def getCellString(totalNumberOfSpaces=None, string=None):
    sideNumberOfSpaces = totalNumberOfSpaces/2
    sideSpaces = ' '*int(sideNumberOfSpaces)
    missingSpaceRefill = checkIfNeededExtraSpace(sideNumberOfSpaces)
    cellString = f"{sideSpaces}{string}{sideSpaces}{missingSpaceRefill}"
    return cellString

def retrieveCellOutput(stringToOutput, numberOfSpacesForKey, maxKeyNameLength, key):
    padding = 3
    terminalColumns = getTerminalColumns()
    numberOfSpacesForKey = maxKeyNameLength - len(key) - 2 + padding*2 # -2 because | |
    availableSpace = terminalColumns - len(key) - numberOfSpacesForKey - 3 - padding*2 # -3 because | at the end and || of the key
    output = ""
    availableSpaceForValue = terminalColumns - len(key) - numberOfSpacesForKey - 3 - padding*2 # -3 because | at the end and || of the key
    numberOfSpacesForValue = availableSpaceForValue - len(stringToOutput) + padding*2

    if "https://" in stringToOutput or "http://" in stringToOutput:
        output += f"{getCellString(numberOfSpacesForValue, stringToOutput)}|"
    else:
        stringBuffer = 0
        stringPiecesNumber = int(len(stringToOutput)/availableSpace)+1
        for _ in range(0,stringPiecesNumber):
            stringPiece = stringToOutput[stringBuffer:]
            stringPiece = stringPiece[:availableSpace]
            numberOfSpacesForValue = availableSpace - len(stringPiece) + padding*2
             

            output += f"{getCellString(numberOfSpacesForValue, stringPiece)}|"
            
            if len(stringToOutput) >= availableSpace:
               output += f"\n|{(numberOfSpacesForKey+len(key))*' '}|"

            stringBuffer += availableSpace
    
    return output

def returnTable(data: dict):
    padding = 3
    maxKeyNameLength = 0
    output = ""
    for key in data.keys():
        if len(key) > maxKeyNameLength:
            maxKeyNameLength = len(key)
    for key in data.keys():
        value = data[key]
        if key != "cveId":
            # To print the key
            numberOfSpacesForKey = maxKeyNameLength - len(key) - 2 + padding*2 # -2 because | |
            output += f"|{getCellString(numberOfSpacesForKey, key)}|"
            # To print the value
            availableSpaceForValue = getTerminalColumns() - len(key) - numberOfSpacesForKey - 3 - padding*2 # -3 because | at the end and || of the key
            if str(type(value)) == "<class 'str'>":
                value = value.replace("\n", " ")
                output += retrieveCellOutput(value, numberOfSpacesForKey, maxKeyNameLength, key)
                
            elif str(type(value)) == "<class 'list'>":
                for item in value:
                    output += retrieveCellOutput(item, numberOfSpacesForKey, maxKeyNameLength, key)
                    if item != value[-1]:
                        output += f"\n|{(numberOfSpacesForKey+len(key))*' '}|"
            # To print the delimiter
            output += f"+{'-'*(maxKeyNameLength+padding*2)}{'-'*(availableSpaceForValue-1+padding*2)}+\n"
        else:
            borderAvailableSpace = getTerminalColumns() - 2 # -2 because + +
            sidesAvailableSpace = getTerminalColumns() - len(value) - 2 # -2 because ||
            topAndBottomBorderDelimiter = f"+{'-'*borderAvailableSpace}+"
            output += f"\n{topAndBottomBorderDelimiter}"
            output += f"|{' '*borderAvailableSpace}|"
            output += f"|{getCellString(sidesAvailableSpace, f'{Fore.GREEN}{value}{Fore.RESET}')}|"
            output += f"|{' '*borderAvailableSpace}|"
            output += topAndBottomBorderDelimiter
    return output

def printParsedCVEData(cve_data):
    cve_id = cve_data["id"]
    parsedCVEData = {}
    parsedCVEData.update({'cveId':cve_id})
    # vulnerability description
    descriptions = cve_data['descriptions']
    for description in descriptions:
        if description['lang'] == "en":
            parsedCVEData.update({"Description":description['value']})
    # vulnerability metrics
    metrics = cve_data["metrics"]
    for metricVersionKey in metrics.keys():
        for metric in metrics[metricVersionKey]:
            cvssData = metric['cvssData']                
            try:
                parsedCVEData.update({f"{metricVersionKey} severity":f"{cvssData['baseSeverity']}"})
            except KeyError:
                parsedCVEData.update({f"{metricVersionKey} severity":f"{metric['baseSeverity']}"})

    # vulnerable affected products
    vulnerableProducts = []
    products = []
    try:
        for configuration in cve_data["configurations"]:
            for node in configuration["nodes"]:
                affectedProducts = node["cpeMatch"]
                for affectedProduct in affectedProducts:
                    if affectedProduct["vulnerable"] == True:
                        vulnerableProducts.append(affectedProduct["criteria"])
        parsedCVEData.update({'Vulnerable Products': vulnerableProducts})
    except KeyError:
        pass
    
    # vulnerability references
    parsedCVEData.update({"References":[]})
    references = cve_data['references']
    for reference in references:
        try:
            parsedCVEData["References"].append(f"{reference['tags']}: {reference['url']}")
        except KeyError:
            parsedCVEData["References"].append(f"{reference['url']}")
    # print vulnerability table
    output = returnTable(parsedCVEData)
    pydoc.pager(output)

def retrieveCVEinfo(cveId):
    cveInfoUrl = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    args = {'cveId':cveId}
    r = requests.get(cveInfoUrl, params=args)
    if r.text != "":
        responseData = json.loads(r.text)
        cveData = responseData['vulnerabilities'][0]['cve']
        printParsedCVEData(cveData)
    else:
        print(f"{Fore.RED}[-] No results found")
        sys.exit(1)

def searchCVEsByKeyword(keyword):
    url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    args = {'noRejected': '', 'keywordSearch': keyword}
    print(f"\n{Fore.GREEN}[+] Retrieving CVE vulnerabilities. Please wait!{Fore.RESET}")
    r = requests.get(url, params=args)
    responseData = json.loads(r.text)
    totalResults = responseData['totalResults']
    resultsPerPage = responseData['resultsPerPage']
    if totalResults > resultsPerPage:
        while True:
            twoThousandMoreRecentConfirmation = input(f"There are {totalResults} CVEs for this keyword and only 2000 results are the maximum allowed to be retrieved so the most recents will be also omitted, do you want to show the 2000 more recent? (y/n)")
            if twoThousandMoreRecentConfirmation == "n":
                break
            elif twoThousandMoreRecentConfirmation == "y":
                args.update({'startIndex': totalResults - resultsPerPage})
                r = requests.get(url, params=args)
                responseData = json.loads(r.text)
                break
            else:
                print(f"{Fore.RED}[-] Invalid answer{Fore.RESET}")

    CVEIDsByDate = reversed(responseData['vulnerabilities'])

    for cve in CVEIDsByDate:
        os.system('clear')
        retrieveCVEinfo(cve['cve']['id'])
        print(f"\n\n\t\t\t{Fore.YELLOW}[i] {Fore.WHITE}Press ENTER to print the next vulnerability")
        while True:
            input()
            break
    
if __name__ == '__main__':
    parser = argparse.ArgumentParser(prog='cve-crawler',
                                     description="CVE-crawler is a terminal tool that can be used to search vulnerabilities for a keyword and display its most relevant information or retrieve the relevant information of a specific CVE id.")
    parser.add_argument('method', help="The method to retrieve info of CVEs: search (search CVEs by keyword), info (retrieve info of a CVE id)", choices=['search','info'])
    parser.add_argument("--keyword", help="Specify a keyword to search CVEs (separated by commas)", dest="keyword")
    parser.add_argument("--cve", help="Specify a CVE to see info of it", dest="cve")
    args = parser.parse_args()

    if args.method == "search":
        if args.cve != None:
            print("[-] cve argument is for 'info' method")
        else:
            if args.keyword != None:
                searchCVEsByKeyword(args.keyword)
            else:
                print("[-] --keyword must exist for 'search' method")
    elif args.method == "info":
        if args.cve == None:
            print("[-] --cve must exist for info method")
            sys.exit(1)
        else:
            # If string cve its in lowercase, transform it to uppercase
            cve = args.cve
            cve = f"{cve.split('-')[0].upper()}-{cve.split('-')[1]}-{cve.split('-')[2]}"
            retrieveCVEinfo(args.cve)

        if args.keyword != None:
            print("[-] --keyword is for 'search' method")
            sys.exit(1)
